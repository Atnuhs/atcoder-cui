
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>go: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">main/go/main.go (45.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "container/heap"
        "fmt"
        "math"
        "os"
        "strconv"
)

var in = bufio.NewScanner(os.Stdin)
var out = bufio.NewWriter(os.Stdout)

type Pair struct {
        u, v int
}

func NewPair(u, v int) *Pair <span class="cov8" title="1">{
        return &amp;Pair{u, v}
}</span>
func (p *Pair) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d %d", p.u, p.v)
}</span>

func init() <span class="cov8" title="1">{
        in.Split(bufio.ScanWords)
        in.Buffer([]byte{}, math.MaxInt64)
}</span>

func Reads() string <span class="cov0" title="0">{
        in.Scan()
        return in.Text()
}</span>

func Readss(n int) []string <span class="cov0" title="0">{
        ret := make([]string, n)
        for i := range ret </span><span class="cov0" title="0">{
                ret[i] = Reads()
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func Readrs(n int) [][]rune <span class="cov0" title="0">{
        ret := make([][]rune, n)
        for i := range ret </span><span class="cov0" title="0">{
                ret[i] = []rune(Reads())
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func Readi() int <span class="cov0" title="0">{
        in.Scan()
        ret, _ := strconv.Atoi(in.Text())
        return ret
}</span>

func Readis(n int) []int <span class="cov0" title="0">{
        ret := make([]int, n)
        for i := range ret </span><span class="cov0" title="0">{
                ret[i] = Readi()
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func ModPow(x, e, mod int) int <span class="cov8" title="1">{
        i := 1
        ret := 1

        for i &lt;= e </span><span class="cov8" title="1">{
                if i&amp;e &gt; 0 </span><span class="cov8" title="1">{
                        ret = (ret * x) % mod
                }</span>
                <span class="cov8" title="1">i &lt;&lt;= 1
                x = (x * x) % mod</span>
        }
        <span class="cov8" title="1">return ret</span>
}

func Inv(x, mod int) int <span class="cov8" title="1">{
        return ModPow(x, mod-2, mod)
}</span>

func PopBack(a *[]int) int <span class="cov8" title="1">{
        ret := (*a)[len(*a)-1]
        *a = (*a)[:len(*a)-1]
        return ret
}</span>

func PopFront(a *[]int) int <span class="cov8" title="1">{
        ret := (*a)[0]
        *a = (*a)[1:]
        return ret
}</span>

func Gcd(a, b int) int <span class="cov8" title="1">{
        if b == 0 </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return Gcd(b, a%b)</span>
}

func Lcm(a, b int) int <span class="cov0" title="0">{
        return a / Gcd(a, b) * b
}</span>

func Sqrt(x int) int <span class="cov8" title="1">{
        return int(math.Sqrt(float64(x)))
}</span>

func NextPerm(a []int) bool <span class="cov0" title="0">{
        // search i
        i := len(a) - 2
        for i &gt;= 0 &amp;&amp; a[i] &gt;= a[i+1] </span><span class="cov0" title="0">{
                i--
        }</span>
        <span class="cov0" title="0">if i &lt; 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">j := len(a) - 1
        for j &gt;= 0 &amp;&amp; a[j] &lt;= a[i] </span><span class="cov0" title="0">{
                j--
        }</span>

        <span class="cov0" title="0">a[i], a[j] = a[j], a[i]

        l := i + 1
        r := len(a) - 1
        for l &lt; r </span><span class="cov0" title="0">{
                a[l], a[r] = a[r], a[l]
                l++
                r--
        }</span>
        <span class="cov0" title="0">return true</span>
}

func Extrema(vals ...int) (int, int) <span class="cov0" title="0">{
        mi, ma := vals[0], vals[0]
        for _, v := range vals </span><span class="cov0" title="0">{
                if v &lt; mi </span><span class="cov0" title="0">{
                        mi = v
                }</span>
                <span class="cov0" title="0">if v &gt; ma </span><span class="cov0" title="0">{
                        ma = v
                }</span>
        }
        <span class="cov0" title="0">return mi, ma</span>
}

func Max(vals ...int) int <span class="cov0" title="0">{
        _, ma := Extrema(vals...)
        return ma
}</span>

func Min(vals ...int) int <span class="cov0" title="0">{
        mi, _ := Extrema(vals...)
        return mi
}</span>

func Sum(vals ...int) int <span class="cov0" title="0">{
        sum := 0
        for _, v := range vals </span><span class="cov0" title="0">{
                sum += v
        }</span>
        <span class="cov0" title="0">return sum</span>
}

func Abs(x int) int <span class="cov0" title="0">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                x = -x
        }</span>
        <span class="cov0" title="0">return x</span>
}

func IsPrime(x int) bool <span class="cov8" title="1">{
        if x == 1 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">rx := Sqrt(x)
        for i := 2; i &lt;= rx; i++ </span><span class="cov8" title="1">{
                if x%i == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func Factorize(x int) []*Pair <span class="cov8" title="1">{
        if x == 1 </span><span class="cov8" title="1">{
                return []*Pair{}
        }</span>

        <span class="cov8" title="1">rx := Sqrt(x)
        n := x
        ret := make([]*Pair, 0)
        for i := 2; i &lt;= rx; i++ </span><span class="cov8" title="1">{
                if n%i != 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">exp := 0
                for n%i == 0 </span><span class="cov8" title="1">{
                        n /= i
                        exp++
                }</span>
                <span class="cov8" title="1">ret = append(ret, NewPair(i, exp))</span>
        }
        <span class="cov8" title="1">if n != 1 </span><span class="cov8" title="1">{
                ret = append(ret, NewPair(n, 1))
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func Mobius(x int) int <span class="cov8" title="1">{
        ret := 1

        rx := Sqrt(x)
        n := x
        for i := 2; i &lt;= rx; i++ </span><span class="cov8" title="1">{
                if n%i != 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if (n/i)%i == 0 </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">n /= i
                ret = -ret</span>
        }

        <span class="cov8" title="1">if n != 1 </span><span class="cov8" title="1">{
                ret = -ret
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func Divisors(x int) []int <span class="cov8" title="1">{
        ret := make([]int, 0)

        rx := Sqrt(x)
        for i := 1; i &lt;= rx; i++ </span><span class="cov8" title="1">{
                if x%i != 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">ret = append(ret, i)
                if i != x/i </span><span class="cov8" title="1">{
                        ret = append(ret, x/i)
                }</span>
        }
        <span class="cov8" title="1">return ret</span>
}

func CountDivisors(pairs []*Pair) int <span class="cov8" title="1">{
        ans := 1
        for _, pe := range pairs </span><span class="cov8" title="1">{
                ans *= (pe.v + 1)
        }</span>
        <span class="cov8" title="1">return ans</span>
}

// Eratosthenes sieve
type EratosthenesSieve struct {
        isPrime   []bool
        minFactor []int
        mobius    []int
}

func NewSieve(n int) *EratosthenesSieve <span class="cov8" title="1">{
        isPrime := make([]bool, n+1)
        minFactor := make([]int, n+1)
        mobius := make([]int, n+1)

        for i := range isPrime </span><span class="cov8" title="1">{
                isPrime[i] = true
                minFactor[i] = -1
                mobius[i] = 1
        }</span>

        <span class="cov8" title="1">isPrime[0] = false
        isPrime[1] = false
        minFactor[1] = 1

        // sieve
        for i := range isPrime </span><span class="cov8" title="1">{
                if !isPrime[i] </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">minFactor[i] = i
                mobius[i] = -1

                for j := i * 2; j &lt;= n; j += i </span><span class="cov8" title="1">{
                        isPrime[j] = false

                        if minFactor[j] == -1 </span><span class="cov8" title="1">{
                                minFactor[j] = i
                        }</span>

                        <span class="cov8" title="1">if (j/i)%i == 0 </span><span class="cov8" title="1">{
                                mobius[j] = 0
                        }</span> else<span class="cov8" title="1"> {
                                mobius[j] = -mobius[j]
                        }</span>
                }
        }
        <span class="cov8" title="1">return &amp;EratosthenesSieve{
                isPrime:   isPrime,
                minFactor: minFactor,
                mobius:    mobius,
        }</span>
}

func (sv *EratosthenesSieve) IsPrime(x int) bool <span class="cov8" title="1">{
        return sv.isPrime[x]
}</span>

func (sv *EratosthenesSieve) Factorize(x int) []*Pair <span class="cov8" title="1">{
        ret := make([]*Pair, 0)
        n := x
        for n &gt; 1 </span><span class="cov8" title="1">{
                p := sv.minFactor[n]
                exp := 0

                for sv.minFactor[n] == p </span><span class="cov8" title="1">{
                        n /= p
                        exp++
                }</span>
                <span class="cov8" title="1">ret = append(ret, NewPair(p, exp))</span>
        }
        <span class="cov8" title="1">return ret</span>
}

func (sv *EratosthenesSieve) Mobius(x int) int <span class="cov8" title="1">{
        return sv.mobius[x]
}</span>

func (sv *EratosthenesSieve) Divisors(x int) []int <span class="cov8" title="1">{
        ret := []int{1}

        f := sv.Factorize(x)
        for _, pe := range f </span><span class="cov8" title="1">{
                n := len(ret)
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        v := 1
                        for j := 0; j &lt; pe.v; j++ </span><span class="cov8" title="1">{
                                v *= pe.u
                                ret = append(ret, ret[i]*v)
                        }</span>
                }
        }
        <span class="cov8" title="1">return ret</span>
}

func (sv *EratosthenesSieve) CountDivisors(x int) int <span class="cov8" title="1">{
        return CountDivisors(sv.Factorize(x))
}</span>

type UnionFind struct {
        data []int
}

func NewUnionFind(n int) *UnionFind <span class="cov0" title="0">{
        data := make([]int, n)
        for i := range data </span><span class="cov0" title="0">{
                data[i] = -1
        }</span>
        <span class="cov0" title="0">return &amp;UnionFind{
                data: data,
        }</span>
}

func (uf *UnionFind) Root(x int) int <span class="cov0" title="0">{
        if uf.data[x] &lt; 0 </span><span class="cov0" title="0">{
                return x
        }</span> else<span class="cov0" title="0"> {
                uf.data[x] = uf.Root(uf.data[x])
                return uf.data[x]
        }</span>
}

func (uf *UnionFind) Family(x, y int) bool <span class="cov0" title="0">{
        return uf.Root(x) == uf.Root(y)
}</span>

func (uf *UnionFind) Size(x int) int <span class="cov0" title="0">{
        return -uf.data[uf.Root(x)]
}</span>

func (uf *UnionFind) Union(x, y int) <span class="cov0" title="0">{
        rx := uf.Root(x)
        ry := uf.Root(y)

        if rx == ry </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if uf.Size(rx) &lt; uf.Size(ry) </span><span class="cov0" title="0">{
                rx = rx ^ ry
                ry = rx ^ ry
                rx = rx ^ ry
        }</span>

        <span class="cov0" title="0">uf.data[rx] += uf.data[ry]
        uf.data[ry] = rx</span>
}

type splay_node struct {
        l, r, p *splay_node
        size    int
        value   int
}

func (n *splay_node) rotate() <span class="cov0" title="0">{
        p := n.p

        if pp := p.p; pp != nil </span><span class="cov0" title="0">{
                if pp.l == p </span><span class="cov0" title="0">{
                        pp.l = n
                }</span> else<span class="cov0" title="0"> {
                        pp.r = n
                }</span>
                <span class="cov0" title="0">n.p = pp</span>
        }

        <span class="cov0" title="0">var c *splay_node
        if p.l == n </span><span class="cov0" title="0">{
                c = n.r
                n.r = p
                p.l = c
        }</span> else<span class="cov0" title="0"> {
                c = n.l
                n.l = p
                p.r = c
        }</span>

        <span class="cov0" title="0">if c != nil </span><span class="cov0" title="0">{
                c.p = p
        }</span>
        <span class="cov0" title="0">p.p = n
        p.update()
        n.update()</span>
}

func (n *splay_node) state() int <span class="cov0" title="0">{
        if n.p == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if n.p.l == n </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">if n.p.r == n </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (n *splay_node) splay() <span class="cov0" title="0">{
        for n.p != nil </span><span class="cov0" title="0">{
                // n has parent

                if n.p.state() == 0 </span><span class="cov0" title="0">{
                        // n.p doesn't have p
                        n.rotate()
                }</span>

                <span class="cov0" title="0">if n.state() == n.p.state() </span><span class="cov0" title="0">{
                        n.p.rotate()
                        n.rotate()
                }</span> else<span class="cov0" title="0"> {
                        n.rotate()
                        n.rotate()
                }</span>
        }
}

func (n *splay_node) update() <span class="cov0" title="0">{
        n.size = 1
        if n.l != nil </span><span class="cov0" title="0">{
                n.size += n.l.size
        }</span>
        <span class="cov0" title="0">if n.r != nil </span><span class="cov0" title="0">{
                n.size += n.r.size
        }</span>
}

func get(ind int, root *splay_node) *splay_node <span class="cov0" title="0">{
        now := root
        for </span><span class="cov0" title="0">{
                lsize := 0
                if now.l != nil </span><span class="cov0" title="0">{
                        lsize = now.l.size
                }</span>
                <span class="cov0" title="0">if ind &lt; lsize </span><span class="cov0" title="0">{
                        now = now.l
                }</span>
                <span class="cov0" title="0">if ind == lsize </span><span class="cov0" title="0">{
                        now.splay()
                        return now
                }</span>
                <span class="cov0" title="0">if ind &gt; lsize </span><span class="cov0" title="0">{
                        now = now.r
                        ind -= lsize + 1
                }</span>
        }
}

type heapImpl []int

func (h heapImpl) Len() int           <span class="cov0" title="0">{ return len(h) }</span>
func (h heapImpl) Less(i, j int) bool <span class="cov0" title="0">{ return h[i] &lt; h[j] }</span>
func (h heapImpl) Swap(i, j int)      <span class="cov0" title="0">{ h[i], h[j] = h[j], h[i] }</span>

func (h *heapImpl) Push(x interface{}) <span class="cov0" title="0">{
        *h = append(*h, x.(int))
}</span>
func (h *heapImpl) Pop() interface{} <span class="cov0" title="0">{
        x := (*h)[len(*h)-1]
        *h = (*h)[:len(*h)-1]
        return x
}</span>

type PriorityQueue struct {
        value heapImpl
}

func NewPriorityQueue() *PriorityQueue <span class="cov0" title="0">{
        value := &amp;heapImpl{}
        heap.Init(value)
        return &amp;PriorityQueue{}
}</span>

func (pq *PriorityQueue) Push(x int) <span class="cov0" title="0">{
        heap.Push(&amp;pq.value, x)
}</span>

func (pq *PriorityQueue) Pop() int <span class="cov0" title="0">{
        x := heap.Pop(&amp;pq.value)
        return x.(int)
}</span>

func NewGraph(n int) [][]int <span class="cov0" title="0">{
        g := make([][]int, n)
        for i := range g </span><span class="cov0" title="0">{
                g[i] = make([]int, 0)
        }</span>
        <span class="cov0" title="0">return g</span>
}

func main() <span class="cov0" title="0">{
        defer out.Flush()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
