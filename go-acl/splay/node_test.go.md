---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: go-acl/main.go
    title: go-acl/main.go
  - icon: ':heavy_check_mark:'
    path: go-acl/splay/map.go
    title: go-acl/splay/map.go
  - icon: ':heavy_check_mark:'
    path: go-acl/splay/node.go
    title: go-acl/splay/node.go
  - icon: ':heavy_check_mark:'
    path: go-acl/splay/set.go
    title: go-acl/splay/set.go
  - icon: ':heavy_check_mark:'
    path: go-acl/splay/set_test.go
    title: go-acl/splay/set_test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/testlib/assert.go
    title: go-acl/testlib/assert.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/depq.go
    title: go-acl/util/depq.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/depq_test.go
    title: go-acl/util/depq_test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/lib.go
    title: go-acl/util/lib.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/lib_test.go
    title: go-acl/util/lib_test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/math.go
    title: go-acl/util/math.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/math_test.go
    title: go-acl/util/math_test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/monoid.go
    title: go-acl/util/monoid.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/segmentTree.go
    title: go-acl/util/segmentTree.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/sieve.go
    title: go-acl/util/sieve.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/sieve_test.go
    title: go-acl/util/sieve_test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/unionfind.go
    title: go-acl/util/unionfind.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/aplusb/verify.test.go
    title: go-acl/verify/aplusb/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/associative_array/verify.test.go
    title: go-acl/verify/associative_array/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/double_ended_priority_queue/verify.test.go
    title: go-acl/verify/double_ended_priority_queue/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/many_aplusb/verify.test.go
    title: go-acl/verify/many_aplusb/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/predecessor_problem/verify.test.go
    title: go-acl/verify/predecessor_problem/verify.test.go
  _extendedRequiredBy:
  - icon: ':heavy_check_mark:'
    path: go-acl/main.go
    title: go-acl/main.go
  - icon: ':heavy_check_mark:'
    path: go-acl/splay/map.go
    title: go-acl/splay/map.go
  - icon: ':heavy_check_mark:'
    path: go-acl/splay/node.go
    title: go-acl/splay/node.go
  - icon: ':heavy_check_mark:'
    path: go-acl/splay/set.go
    title: go-acl/splay/set.go
  - icon: ':heavy_check_mark:'
    path: go-acl/splay/set_test.go
    title: go-acl/splay/set_test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/testlib/assert.go
    title: go-acl/testlib/assert.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/depq.go
    title: go-acl/util/depq.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/depq_test.go
    title: go-acl/util/depq_test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/lib.go
    title: go-acl/util/lib.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/lib_test.go
    title: go-acl/util/lib_test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/math.go
    title: go-acl/util/math.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/math_test.go
    title: go-acl/util/math_test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/monoid.go
    title: go-acl/util/monoid.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/segmentTree.go
    title: go-acl/util/segmentTree.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/sieve.go
    title: go-acl/util/sieve.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/sieve_test.go
    title: go-acl/util/sieve_test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/util/unionfind.go
    title: go-acl/util/unionfind.go
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/aplusb/verify.test.go
    title: go-acl/verify/aplusb/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/associative_array/verify.test.go
    title: go-acl/verify/associative_array/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/double_ended_priority_queue/verify.test.go
    title: go-acl/verify/double_ended_priority_queue/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/many_aplusb/verify.test.go
    title: go-acl/verify/many_aplusb/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/predecessor_problem/verify.test.go
    title: go-acl/verify/predecessor_problem/verify.test.go
  _isVerificationFailed: false
  _pathExtension: go
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes: {}
  bundledCode: "Traceback (most recent call last):\n  File \"/home/runner/.local/lib/python3.10/site-packages/onlinejudge_verify/documentation/build.py\"\
    , line 71, in _render_source_code_stat\n    bundled_code = language.bundle(stat.path,\
    \ basedir=basedir, options={'include_paths': [basedir]}).decode()\n  File \"/home/runner/.local/lib/python3.10/site-packages/onlinejudge_verify/languages/user_defined.py\"\
    , line 68, in bundle\n    raise RuntimeError('bundler is not specified: {}'.format(str(path)))\n\
    RuntimeError: bundler is not specified: go-acl/splay/node_test.go\n"
  code: "package splay\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"testing\"\n\n\t\
    \"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\
    \t\"golang.org/x/exp/slices\"\n)\n\nfunc TestSplayNode_splay(t *testing.T) {\n\
    \tvalues := struct {\n\t\tpp, p, t, ppc, pc, tcl, tcr int\n\t}{\n\t\tpp:  1,\n\
    \t\tp:   2,\n\t\tt:   3,\n\t\tppc: 4,\n\t\tpc:  5,\n\t\ttcl: 6,\n\t\ttcr: 7,\n\
    \t}\n\ttype treeStruct struct {\n\t\tppLeft bool\n\t\tpLeft  bool\n\t}\n\n\tgenArr\
    \ := func(ts treeStruct) []interface{} {\n\t\tt := []interface{}{values.tcl, values.t,\
    \ values.tcr}\n\t\tvar p []interface{}\n\t\tif ts.pLeft {\n\t\t\tp = append(t,\
    \ values.p, values.pc)\n\t\t} else {\n\t\t\tp = append([]interface{}{values.pc,\
    \ values.p}, t...)\n\t\t}\n\n\t\tvar pp []interface{}\n\t\tif ts.ppLeft {\n\t\t\
    \tpp = append(p, values.pp, values.ppc)\n\t\t} else {\n\t\t\tpp = append([]interface{}{values.ppc,\
    \ values.pp}, p...)\n\t\t}\n\t\treturn pp\n\t}\n\n\texpected := func(format string,\
    \ ts treeStruct) string {\n\t\treturn fmt.Sprintf(format, genArr(ts)...)\n\t}\n\
    \n\ttests := map[string]struct {\n\t\ttreeStrcut  treeStruct\n\t\texpectedFmt\
    \ string\n\t}{\n\t\t\"p is left child of pp and t is left child of p\": {\n\t\t\
    \ttreeStrcut:  treeStruct{ppLeft: true, pLeft: true},\n\t\t\texpectedFmt: \"((%d)\
    \ %d ((%d) %d ((%d) %d (%d))))\",\n\t\t},\n\t\t\"p is left child of pp and t is\
    \ right child of p\": {\n\t\t\ttreeStrcut:  treeStruct{ppLeft: true, pLeft: false},\n\
    \t\t\texpectedFmt: \"(((%d) %d (%d)) %d ((%d) %d (%d)))\",\n\t\t},\n\t\t\"p is\
    \ right child of pp and t is left child of p\": {\n\t\t\ttreeStrcut:  treeStruct{ppLeft:\
    \ false, pLeft: true},\n\t\t\texpectedFmt: \"(((%d) %d (%d)) %d ((%d) %d (%d)))\"\
    ,\n\t\t},\n\t\t\"p is right child of pp and t is right child of p\": {\n\t\t\t\
    treeStrcut:  treeStruct{ppLeft: false, pLeft: false},\n\t\t\texpectedFmt: \"((((%d)\
    \ %d (%d)) %d (%d)) %d (%d))\",\n\t\t},\n\t}\n\n\tfor caseName, test := range\
    \ tests {\n\t\tt.Run(caseName, func(t *testing.T) {\n\t\t\ttarget := NewSplayNode(values.t,\
    \ -1)\n\t\t\ttarget.l = NewSplayNode(values.tcl, -1)\n\t\t\ttarget.r = NewSplayNode(values.tcr,\
    \ -1)\n\t\t\ttarget.l.p = target\n\t\t\ttarget.r.p = target\n\t\t\tp := NewSplayNode(values.p,\
    \ -1)\n\t\t\tpc := NewSplayNode(values.pc, -1)\n\t\t\ttarget.p = p\n\t\t\tpc.p\
    \ = p\n\t\t\tif test.treeStrcut.pLeft {\n\t\t\t\tp.l = target\n\t\t\t\tp.r = pc\n\
    \t\t\t} else {\n\t\t\t\tp.l = pc\n\t\t\t\tp.r = target\n\t\t\t}\n\n\t\t\tpp :=\
    \ NewSplayNode(values.pp, -1)\n\t\t\tppc := NewSplayNode(values.ppc, -1)\n\t\t\
    \tp.p = pp\n\t\t\tppc.p = pp\n\t\t\tif test.treeStrcut.ppLeft {\n\t\t\t\tpp.l\
    \ = p\n\t\t\t\tpp.r = ppc\n\t\t\t} else {\n\t\t\t\tpp.l = ppc\n\t\t\t\tpp.r =\
    \ p\n\t\t\t}\n\n\t\t\tt.Log(pp.String())\n\t\t\ttarget.splay()\n\t\t\texpected\
    \ := expected(test.expectedFmt, test.treeStrcut)\n\t\t\tif diff := cmp.Diff(expected,\
    \ target.String()); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\nexpected:\\n%s\\nactual:\\\
    n%s\", expected, target.String())\n\t\t\t\tt.Errorf(\"\\ndiff: %s\", diff)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n\nconst N = 10\n\nfunc generateRandomTestCase(t *testing.T,\
    \ n int) (expected []int, actual *SplayNode) {\n\tactual = nil\n\texpected = make([]int,\
    \ 0, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tnn := NewSplayNode(i, -1)\n\t\tif actual\
    \ == nil {\n\t\t\tactual = nn\n\t\t\texpected = append(expected, i)\n\t\t} else\
    \ {\n\t\t\tj := rand.Intn(actual.size + 1)\n\t\t\tactual = actual.InsertAt(j,\
    \ nn)\n\t\t\texpected = insert(j, i, expected)\n\t\t}\n\t\tassertValues(t, actual,\
    \ expected)\n\t}\n\tt.Logf(\"\\n%s\", actual.describe(0))\n\treturn expected,\
    \ actual\n}\n\nfunc assertValues(t *testing.T, root *SplayNode, expected []int)\
    \ {\n\tt.Helper()\n\tvar actual []int\n\tif root != nil {\n\t\tactual = root.values()\n\
    \t}\n\topts := []cmp.Option{\n\t\tcmpopts.EquateEmpty(),\n\t}\n\tif diff := cmp.Diff(expected,\
    \ actual, opts...); diff != \"\" {\n\t\tt.Logf(\"Expected: %v\", expected)\n\t\
    \tt.Logf(\"Actual  : %v\", actual)\n\t\tt.Errorf(\"%s\", diff)\n\t}\n}\n\nfunc\
    \ TestSplayNode_values(t *testing.T) {\n\tn := N\n\texpected, root := generateRandomTestCase(t,\
    \ n)\n\tassertValues(t, root, expected)\n\tif root.size != n {\n\t\tt.Errorf(\"\
    expected node size: %d but got: %d\", n, root.size)\n\t}\n}\n\nfunc TestSplayNode_FindAtSplay(t\
    \ *testing.T) {\n\tn := N\n\texpected, root := generateRandomTestCase(t, n)\n\n\
    \tfor i := 0; i < n; i++ {\n\t\troot = root.FindAt(i)\n\n\t\tif root == nil {\n\
    \t\t\tt.Fatalf(\"root should not be nil in safe index access %d: %d\", i, n)\n\
    \t\t}\n\n\t\tif root.p != nil {\n\t\t\tt.Fatal(\"FindAtAndSplay result should\
    \ be root\")\n\t\t}\n\t\tassertValues(t, root, expected)\n\t}\n}\n\nfunc insert(i\
    \ int, v int, arr []int) []int {\n\tl := arr[:i]\n\tvar r []int\n\tif i < len(arr)\
    \ {\n\t\tr = arr[i:]\n\t}\n\treturn append(l, append([]int{v}, r...)...)\n}\n\n\
    func TestSplayNode_InsertAt(t *testing.T) {\n\tn := N\n\texpected, root := generateRandomTestCase(t,\
    \ n)\n\n\tfor i := 0; i < n; i++ {\n\t\troot = root.FindAt(i)\n\t\tassertValues(t,\
    \ root, expected)\n\t}\n}\n\nfunc delete(i int, arr []int) []int {\n\tl := arr[:i]\n\
    \tvar r []int\n\tif i+1 < len(arr) {\n\t\tr = arr[i+1:]\n\t}\n\treturn append(l,\
    \ r...)\n}\n\nfunc TestSplayNode_DeleteAt(t *testing.T) {\n\tn := N\n\texpected,\
    \ root := generateRandomTestCase(t, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tj :=\
    \ rand.Intn(root.size)\n\t\troot, _ = root.DeleteAt(j)\n\t\texpected = delete(j,\
    \ expected)\n\t\tassertValues(t, root, expected)\n\t}\n}\n\nfunc TestSplayNode_maxRank(t\
    \ *testing.T) {\n\tn := 10\n\tm := 10\n\tresult := make([][]int, n+1)\n\tfor in\
    \ := 0; in <= n; in++ {\n\t\tnn := 1 << in\n\t\tresult[in] = make([]int, m+1)\n\
    \t\tfor im := 0; im <= m; im++ {\n\t\t\tt.Log(in, im)\n\t\t\tmm := 1 << im\n\t\
    \t\troot := NewSplayNode(0, -1)\n\t\t\tfor i := 1; i < nn; i++ {\n\t\t\t\troot\
    \ = root.InsertAt(root.size, NewSplayNode(i, -1))\n\t\t\t}\n\n\t\t\tfor i := 0;\
    \ i < mm; i++ {\n\t\t\t\troot = root.FindAt(rand.Intn(root.size))\n\t\t\t}\n\n\
    \t\t\tresult[in][im] = root.maxRank(0)\n\t\t}\n\t}\n\n\tfor i := range result\
    \ {\n\t\tt.Log(result[i])\n\t}\n}\n\nfunc TestSplayNode_Ge(t *testing.T) {\n\t\
    tests := map[string]struct {\n\t\tvalues   []int\n\t\tgeV      int\n\t\texpected\
    \ int\n\t}{\n\t\t\"Less than all values\": {\n\t\t\tvalues:   []int{10, 20, 30,\
    \ 40},\n\t\t\tgeV:      9,\n\t\t\texpected: 0,\n\t\t},\n\t\t\"Equal to first value\"\
    : {\n\t\t\tvalues:   []int{10, 20, 30, 40},\n\t\t\tgeV:      10,\n\t\t\texpected:\
    \ 0,\n\t\t},\n\t\t\"More than first value\": {\n\t\t\tvalues:   []int{10, 20,\
    \ 30, 40},\n\t\t\tgeV:      11,\n\t\t\texpected: 1,\n\t\t},\n\t\t\"Less than last\
    \ value\": {\n\t\t\tvalues:   []int{10, 20, 30, 40},\n\t\t\tgeV:      39,\n\t\t\
    \texpected: 3,\n\t\t},\n\t\t\"Equal to last value\": {\n\t\t\tvalues:   []int{10,\
    \ 20, 30, 40},\n\t\t\tgeV:      40,\n\t\t\texpected: 3,\n\t\t},\n\t\t\"More than\
    \ all values\": {\n\t\t\tvalues:   []int{10, 20, 30, 40},\n\t\t\tgeV:      41,\n\
    \t\t\texpected: 4,\n\t\t},\n\t}\n\n\tfor caseName, test := range tests {\n\t\t\
    t.Run(caseName, func(t *testing.T) {\n\t\t\troot := NewSplayNode(test.values[0],\
    \ -1)\n\t\t\tfor i := 1; i < len(test.values); i++ {\n\t\t\t\troot = root.Insert(NewSplayNode(test.values[i],\
    \ -1))\n\t\t\t}\n\n\t\t\tidx := root.Ge(test.geV)\n\t\t\tt.Log(root)\n\t\t\tif\
    \ test.expected != idx {\n\t\t\t\tt.Errorf(\"expected: %d, but got %d\", test.expected,\
    \ root.index())\n\t\t\t}\n\t\t\tif root.size != len(test.values) {\n\t\t\t\tt.Errorf(\"\
    expected size %d but got %d\", len(test.values), root.size)\n\t\t\t}\n\t\t})\n\
    \t}\n}\n\nfunc TestSplayNode_Insert(t *testing.T) {\n\tn := N\n\texpected := make([]int,\
    \ n)\n\tfor i := range expected {\n\t\texpected[i] = rand.Intn(n)\n\t}\n\troot\
    \ := NewSplayNode(expected[0], -1)\n\tfor i := 1; i < n; i++ {\n\t\troot = root.Insert(NewSplayNode(expected[i],\
    \ -1))\n\t}\n\tslices.Sort(expected)\n\texpected = slices.Compact(expected)\n\t\
    assertValues(t, root, expected)\n}\n\nfunc TestSplayNode_Delete(t *testing.T)\
    \ {\n\ttype expected struct {\n\t\thasDropped bool\n\t\tdropped    int\n\t\trest\
    \       []int\n\t}\n\n\ttests := map[string]struct {\n\t\tdata     []int\n\t\t\
    delete   int\n\t\texpected expected\n\t}{\n\t\t\"delete an existing value\": {\n\
    \t\t\tdata:     []int{1, 2, 3, 4, 5},\n\t\t\tdelete:   1,\n\t\t\texpected: expected{hasDropped:\
    \ true, dropped: 1, rest: []int{2, 3, 4, 5}},\n\t\t},\n\t\t\"delete a non-existing\
    \ value\": {\n\t\t\tdata:     []int{1, 2, 3, 4, 5},\n\t\t\tdelete:   6,\n\t\t\t\
    expected: expected{hasDropped: false, dropped: 0, rest: []int{1, 2, 3, 4, 5}},\n\
    \t\t},\n\t\t\"delete an existing value and no rest\": {\n\t\t\tdata:     []int{1},\n\
    \t\t\tdelete:   1,\n\t\t\texpected: expected{hasDropped: true, dropped: 1, rest:\
    \ nil},\n\t\t},\n\t}\n\n\tfor caseName, test := range tests {\n\t\tt.Run(caseName,\
    \ func(t *testing.T) {\n\t\t\t// construct splay tree\n\t\t\troot := NewSplayNode(test.data[0],\
    \ -1)\n\t\t\tfor i := 1; i < len(test.data); i++ {\n\t\t\t\troot = root.Insert(NewSplayNode(test.data[i],\
    \ -1))\n\t\t\t}\n\n\t\t\t// do delete\n\t\t\troot, actualDropped := root.Delete(NewSplayNode(test.delete,\
    \ -1))\n\n\t\t\t// check dropped\n\t\t\tif test.expected.hasDropped != (actualDropped\
    \ != nil) {\n\t\t\t\tt.Errorf(\"expected has dropped?: %t, but actual has dropped?:\
    \ %t\", test.expected.hasDropped, actualDropped != nil)\n\t\t\t}\n\n\t\t\tif !test.expected.hasDropped\
    \ {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\texpectedDropped := NewSplayNode(test.expected.dropped,\
    \ -1)\n\t\t\tif diff := cmp.Diff(expectedDropped.key, actualDropped.key); diff\
    \ != \"\" {\n\t\t\t\tt.Errorf(\"expected dropped value is %v but actual is %v\"\
    , test.expected.dropped, actualDropped)\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\n\t\t\
    \t// check rest\n\t\t\tassertValues(t, root, test.expected.rest)\n\t\t})\n\t}\n\
    }\n\nfunc BenchmarkSplayNode(b *testing.B) {\n\tn := 10000\n\tconstructSplayTree\
    \ := func() (root *SplayNode) {\n\t\troot = NewSplayNode(rand.Intn(n), -1)\n\t\
    \tfor i := 0; i < n; i++ {\n\t\t\troot.Insert(NewSplayNode(rand.Intn(n), -1))\n\
    \t\t}\n\t\treturn root\n\t}\n\n\tb.Run(\"Find\", func(b *testing.B) {\n\t\tdata\
    \ := constructSplayTree()\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < 100; i++ {\n\
    \t\t\t_ = data.FindAtSub(rand.Intn(b.N))\n\t\t}\n\t})\n\tb.Run(\"FindAtAndSplay\"\
    , func(b *testing.B) {\n\t\tdata := constructSplayTree()\n\t\tb.ResetTimer()\n\
    \t\tfor i := 0; i < b.N; i++ {\n\t\t\tdata = data.FindAt(rand.Intn(b.N))\n\t\t\
    }\n\t})\n\n\tb.Run(\"Insert Delete\", func(b *testing.B) {\n\t\tdata := constructSplayTree()\n\
    \t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tswitch rand.Intn(2)\
    \ {\n\t\t\tcase 0: // insert\n\t\t\t\tdata = data.Insert(NewSplayNode(rand.Intn(b.N),\
    \ -1))\n\t\t\tcase 1:\n\t\t\t\tdata, _ = data.Delete(NewSplayNode(rand.Intn(b.N),\
    \ -1))\n\t\t\t}\n\t\t}\n\t})\n}\n"
  dependsOn:
  - go-acl/verify/predecessor_problem/verify.test.go
  - go-acl/verify/associative_array/verify.test.go
  - go-acl/verify/many_aplusb/verify.test.go
  - go-acl/verify/aplusb/verify.test.go
  - go-acl/verify/double_ended_priority_queue/verify.test.go
  - go-acl/testlib/assert.go
  - go-acl/main.go
  - go-acl/splay/map.go
  - go-acl/splay/node.go
  - go-acl/splay/set.go
  - go-acl/splay/set_test.go
  - go-acl/util/unionfind.go
  - go-acl/util/sieve_test.go
  - go-acl/util/math.go
  - go-acl/util/monoid.go
  - go-acl/util/depq_test.go
  - go-acl/util/lib_test.go
  - go-acl/util/lib.go
  - go-acl/util/math_test.go
  - go-acl/util/depq.go
  - go-acl/util/sieve.go
  - go-acl/util/segmentTree.go
  isVerificationFile: false
  path: go-acl/splay/node_test.go
  requiredBy:
  - go-acl/testlib/assert.go
  - go-acl/main.go
  - go-acl/splay/map.go
  - go-acl/splay/node.go
  - go-acl/splay/set.go
  - go-acl/splay/set_test.go
  - go-acl/util/unionfind.go
  - go-acl/util/sieve_test.go
  - go-acl/util/math.go
  - go-acl/util/monoid.go
  - go-acl/util/depq_test.go
  - go-acl/util/lib_test.go
  - go-acl/util/lib.go
  - go-acl/util/math_test.go
  - go-acl/util/depq.go
  - go-acl/util/sieve.go
  - go-acl/util/segmentTree.go
  timestamp: '2023-11-21 21:27:14+09:00'
  verificationStatus: LIBRARY_ALL_AC
  verifiedWith:
  - go-acl/verify/predecessor_problem/verify.test.go
  - go-acl/verify/associative_array/verify.test.go
  - go-acl/verify/many_aplusb/verify.test.go
  - go-acl/verify/aplusb/verify.test.go
  - go-acl/verify/double_ended_priority_queue/verify.test.go
documentation_of: go-acl/splay/node_test.go
layout: document
redirect_from:
- /library/go-acl/splay/node_test.go
- /library/go-acl/splay/node_test.go.html
title: go-acl/splay/node_test.go
---
