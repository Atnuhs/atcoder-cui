---
data:
  _extendedDependsOn:
  - icon: ':question:'
    path: go-acl/main.go
    title: go-acl/main.go
  - icon: ':question:'
    path: go-acl/splay/map.go
    title: go-acl/splay/map.go
  - icon: ':question:'
    path: go-acl/splay/node.go
    title: go-acl/splay/node.go
  - icon: ':question:'
    path: go-acl/splay/node_test.go
    title: go-acl/splay/node_test.go
  - icon: ':question:'
    path: go-acl/splay/set.go
    title: go-acl/splay/set.go
  - icon: ':question:'
    path: go-acl/splay/set_test.go
    title: go-acl/splay/set_test.go
  - icon: ':question:'
    path: go-acl/testlib/assert.go
    title: go-acl/testlib/assert.go
  - icon: ':question:'
    path: go-acl/util/depq.go
    title: go-acl/util/depq.go
  - icon: ':question:'
    path: go-acl/util/depq_test.go
    title: go-acl/util/depq_test.go
  - icon: ':question:'
    path: go-acl/util/lib.go
    title: go-acl/util/lib.go
  - icon: ':question:'
    path: go-acl/util/lib_test.go
    title: go-acl/util/lib_test.go
  - icon: ':question:'
    path: go-acl/util/math.go
    title: go-acl/util/math.go
  - icon: ':question:'
    path: go-acl/util/math_test.go
    title: go-acl/util/math_test.go
  - icon: ':question:'
    path: go-acl/util/monoid.go
    title: go-acl/util/monoid.go
  - icon: ':question:'
    path: go-acl/util/segmentTree.go
    title: go-acl/util/segmentTree.go
  - icon: ':question:'
    path: go-acl/util/sieve.go
    title: go-acl/util/sieve.go
  - icon: ':question:'
    path: go-acl/util/unionfind.go
    title: go-acl/util/unionfind.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/aplusb/verify.test.go
    title: go-acl/verify/aplusb/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/associative_array/verify.test.go
    title: go-acl/verify/associative_array/verify.test.go
  - icon: ':x:'
    path: go-acl/verify/double_ended_priority_queue/verify.test.go
    title: go-acl/verify/double_ended_priority_queue/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/many_aplusb/verify.test.go
    title: go-acl/verify/many_aplusb/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/predecessor_problem/verify.test.go
    title: go-acl/verify/predecessor_problem/verify.test.go
  _extendedRequiredBy:
  - icon: ':question:'
    path: go-acl/main.go
    title: go-acl/main.go
  - icon: ':question:'
    path: go-acl/splay/map.go
    title: go-acl/splay/map.go
  - icon: ':question:'
    path: go-acl/splay/node.go
    title: go-acl/splay/node.go
  - icon: ':question:'
    path: go-acl/splay/node_test.go
    title: go-acl/splay/node_test.go
  - icon: ':question:'
    path: go-acl/splay/set.go
    title: go-acl/splay/set.go
  - icon: ':question:'
    path: go-acl/splay/set_test.go
    title: go-acl/splay/set_test.go
  - icon: ':question:'
    path: go-acl/testlib/assert.go
    title: go-acl/testlib/assert.go
  - icon: ':question:'
    path: go-acl/util/depq.go
    title: go-acl/util/depq.go
  - icon: ':question:'
    path: go-acl/util/depq_test.go
    title: go-acl/util/depq_test.go
  - icon: ':question:'
    path: go-acl/util/lib.go
    title: go-acl/util/lib.go
  - icon: ':question:'
    path: go-acl/util/lib_test.go
    title: go-acl/util/lib_test.go
  - icon: ':question:'
    path: go-acl/util/math.go
    title: go-acl/util/math.go
  - icon: ':question:'
    path: go-acl/util/math_test.go
    title: go-acl/util/math_test.go
  - icon: ':question:'
    path: go-acl/util/monoid.go
    title: go-acl/util/monoid.go
  - icon: ':question:'
    path: go-acl/util/segmentTree.go
    title: go-acl/util/segmentTree.go
  - icon: ':question:'
    path: go-acl/util/sieve.go
    title: go-acl/util/sieve.go
  - icon: ':question:'
    path: go-acl/util/unionfind.go
    title: go-acl/util/unionfind.go
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/aplusb/verify.test.go
    title: go-acl/verify/aplusb/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/associative_array/verify.test.go
    title: go-acl/verify/associative_array/verify.test.go
  - icon: ':x:'
    path: go-acl/verify/double_ended_priority_queue/verify.test.go
    title: go-acl/verify/double_ended_priority_queue/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/many_aplusb/verify.test.go
    title: go-acl/verify/many_aplusb/verify.test.go
  - icon: ':heavy_check_mark:'
    path: go-acl/verify/predecessor_problem/verify.test.go
    title: go-acl/verify/predecessor_problem/verify.test.go
  _isVerificationFailed: true
  _pathExtension: go
  _verificationStatusIcon: ':question:'
  attributes: {}
  bundledCode: "Traceback (most recent call last):\n  File \"/home/runner/.local/lib/python3.10/site-packages/onlinejudge_verify/documentation/build.py\"\
    , line 71, in _render_source_code_stat\n    bundled_code = language.bundle(stat.path,\
    \ basedir=basedir, options={'include_paths': [basedir]}).decode()\n  File \"/home/runner/.local/lib/python3.10/site-packages/onlinejudge_verify/languages/user_defined.py\"\
    , line 68, in bundle\n    raise RuntimeError('bundler is not specified: {}'.format(str(path)))\n\
    RuntimeError: bundler is not specified: go-acl/util/sieve_test.go\n"
  code: "package util\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n)\n\n\
    func TestEratosthenesSieve_IsPrime(t *testing.T) {\n\tmaxX := 3 * 100000\n\ttestCases\
    \ := []struct {\n\t\tdesc string\n\t\tx    int\n\t\twant bool\n\t}{\n\t\t{desc:\
    \ \"one\", x: 1, want: false},\n\t\t{desc: \"small prime\", x: 2, want: true},\n\
    \t\t{desc: \"small not prime\", x: 4, want: false},\n\t\t{desc: \"prime?\", x:\
    \ 57, want: false},\n\t\t{desc: \"large prime\", x: 104729, want: true},\n\t\t\
    {desc: \"large not prime\", x: 111111, want: false},\n\t}\n\tsv := NewSieve(maxX)\n\
    \n\tfor _, tc := range testCases {\n\t\tt.Run(tc.desc, func(t *testing.T) {\n\t\
    \t\tgot := sv.IsPrime(tc.x)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"%d\
    \ is Prime?, expected %t, but got %t\", tc.x, tc.want, got)\n\t\t\t}\n\t\t})\n\
    \t}\n}\n\nfunc FuzzEratosthenesSieve_IsPrime(f *testing.F) {\n\tmaxX := 3 * 100000\n\
    \tsv := NewSieve(maxX)\n\tf.Add(0)\n\tf.Add(1)\n\tf.Add(9)\n\tf.Add(123456)\n\t\
    f.Add(1000000007)\n\tf.Fuzz(func(t *testing.T, a int) {\n\t\tif 1 > a || a > maxX\
    \ {\n\t\t\treturn\n\t\t}\n\n\t\t// Perform prime number determination in two different\
    \ ways\n\t\t// method1 O(sqrt(N))\n\t\tret1 := IsPrime(a)\n\t\t// method2 EratosthenesSieve\n\
    \t\tret2 := sv.IsPrime(a)\n\t\tif ret1 != ret2 {\n\t\t\tt.Errorf(\"%d is Prime?,\
    \ method1: %t, but method2 %t\", a, ret1, ret2)\n\t\t}\n\t})\n}\n\nfunc TestEratosthenesSieve_Factorize(t\
    \ *testing.T) {\n\tmaxX := 3 * 100000\n\ttestCases := []struct {\n\t\tdesc string\n\
    \t\tx    int\n\t\twant []*Pair[int]\n\t}{\n\t\t{desc: \"one\", x: 1, want: []*Pair[int]{}},\n\
    \t\t{desc: \"simple prime number\", x: 2, want: []*Pair[int]{NewPair(2, 1)}},\n\
    \t\t{desc: \"simple composite number\", x: 12, want: []*Pair[int]{NewPair(2, 2),\
    \ NewPair(3, 1)}},\n\t\t{desc: \"large prime number\", x: 104729, want: []*Pair[int]{NewPair(104729,\
    \ 1)}},\n\t\t{\n\t\t\tdesc: \"large composite number\",\n\t\t\tx:    1260,\n\t\
    \t\twant: []*Pair[int]{NewPair(2, 2), NewPair(3, 2), NewPair(5, 1), NewPair(7,\
    \ 1)},\n\t\t},\n\t}\n\n\tsv := NewSieve(maxX)\n\n\tfor _, tc := range testCases\
    \ {\n\t\tt.Run(tc.desc, func(t *testing.T) {\n\t\t\tgot := sv.Factorize(tc.x)\n\
    \t\t\tif !reflect.DeepEqual(tc.want, got) {\n\t\t\t\tt.Errorf(\"factorize %d result,\
    \ expected %v, but got %v\", tc.x, tc.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\n\
    func FuzzEratosthenesSieve_Factorize(f *testing.F) {\n\tmaxX := 3 * 100000\n\t\
    sv := NewSieve(maxX)\n\tf.Add(0)\n\tf.Add(1)\n\tf.Add(9)\n\tf.Add(123456)\n\t\
    f.Add(1000000007)\n\tf.Fuzz(func(t *testing.T, a int) {\n\t\tif 1 > a || a > maxX\
    \ {\n\t\t\treturn\n\t\t}\n\t\t// Perform Factorization in two different ways\n\
    \t\t// method1 O(sqrt(N))\n\t\tret1 := Factorize(a)\n\t\t// method2 EratosthenesSieve\n\
    \t\tret2 := sv.Factorize(a)\n\t\tif !reflect.DeepEqual(ret1, ret2) {\n\t\t\tt.Errorf(\"\
    factorize %d, method1: %v, but method2 %v\", a, ret1, ret2)\n\t\t}\n\t})\n}\n\n\
    func TestEratosthenesSieve_Divisors(t *testing.T) {\n\tmaxX := 3 * 100000\n\t\
    testCases := []struct {\n\t\tdesc string\n\t\tx    int\n\t\twant []int\n\t}{\n\
    \t\t{desc: \"one\", x: 1, want: []int{1}},\n\t\t{desc: \"simple prime number\"\
    , x: 2, want: []int{1, 2}},\n\t\t{desc: \"simple composite number\", x: 12, want:\
    \ []int{1, 2, 3, 4, 6, 12}},\n\t\t{desc: \"large prime number\", x: 104729, want:\
    \ []int{1, 104729}},\n\t}\n\n\tsv := NewSieve(maxX)\n\n\tfor _, tc := range testCases\
    \ {\n\t\tt.Run(tc.desc, func(t *testing.T) {\n\t\t\tgot := sv.Divisors(tc.x)\n\
    \t\t\tsort.Ints(got)\n\t\t\tsort.Ints(tc.want)\n\t\t\tif !reflect.DeepEqual(tc.want,\
    \ got) {\n\t\t\t\tt.Errorf(\"factorize %d result, expected %v, but got %v\", tc.x,\
    \ tc.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc FuzzEratosthenesSieve_Divisors(f\
    \ *testing.F) {\n\tmaxX := 3 * 100000\n\tsv := NewSieve(maxX)\n\tf.Add(0)\n\t\
    f.Add(1)\n\tf.Add(9)\n\tf.Add(123456)\n\tf.Add(1000000007)\n\tf.Fuzz(func(t *testing.T,\
    \ a int) {\n\t\tif 1 > a || a > maxX {\n\t\t\treturn\n\t\t}\n\t\t// Enumerate\
    \ divisors in two different ways\n\t\t// method1 O(sqrt(N))\n\t\tret1 := Divisors(a)\n\
    \t\t// method2 EratosthenesSieve\n\t\tret2 := sv.Divisors(a)\n\t\tsort.Ints(ret1)\n\
    \t\tsort.Ints(ret2)\n\t\tif !reflect.DeepEqual(ret1, ret2) {\n\t\t\tt.Errorf(\"\
    enumerate %d divisors, method1: %v, but method2 %v\", a, ret1, ret2)\n\t\t}\n\t\
    })\n}\n\nfunc TestEratosthenesSieve_Mobius(t *testing.T) {\n\tmaxX := 3 * 100000\n\
    \ttestCases := []struct {\n\t\tdesc string\n\t\tx    int\n\t\twant int\n\t}{\n\
    \t\t{desc: \"one\", x: 1, want: 1},\n\t\t{desc: \"simple prime number\", x: 2,\
    \ want: -1},\n\t\t{desc: \"simple composite number\", x: 6, want: 1},\n\t\t{desc:\
    \ \"simple composite number\", x: 30, want: -1},\n\t\t{desc: \"simple composite\
    \ number\", x: 4, want: 0},\n\t\t{desc: \"simple composite number\", x: 12, want:\
    \ 0},\n\t\t{desc: \"large prime number\", x: 104729, want: -1},\n\t}\n\n\tsv :=\
    \ NewSieve(maxX)\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.desc, func(t\
    \ *testing.T) {\n\t\t\tgot := sv.Mobius(tc.x)\n\n\t\t\tif tc.want != got {\n\t\
    \t\t\tt.Errorf(\"%d Mebius function, expected %d, but got %d\", tc.x, tc.want,\
    \ got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc FuzzEratosthenesSieve_Mobius(f *testing.F)\
    \ {\n\tmaxX := 3 * 100000\n\tsv := NewSieve(maxX)\n\tf.Add(0)\n\tf.Add(1)\n\t\
    f.Add(9)\n\tf.Add(123456)\n\tf.Add(1000000007)\n\tf.Fuzz(func(t *testing.T, a\
    \ int) {\n\t\tif 1 > a || a > maxX {\n\t\t\treturn\n\t\t}\n\t\t// Mobius function\
    \ in two different ways\n\t\t// method1 O(sqrt(N))\n\t\tret1 := Mobius(a)\n\t\t\
    // method2 EratosthenesSieve\n\t\tret2 := sv.Mobius(a)\n\t\tif ret1 != ret2 {\n\
    \t\t\tt.Errorf(\"%d mobius function, method1: %v, but method2 %v\", a, ret1, ret2)\n\
    \t\t}\n\t})\n}\n\nfunc TestCountDivisors(t *testing.T) {\n\tmaxX := 3 * 100000\n\
    \ttestCases := []struct {\n\t\tdesc string\n\t\tx    int\n\t\twant int\n\t}{\n\
    \t\t{desc: \"one\", x: 1, want: 1},\n\t\t{desc: \"simple prime number\", x: 2,\
    \ want: 2},\n\t\t{desc: \"simple composite number\", x: 12, want: 6},\n\t\t{desc:\
    \ \"large prime number\", x: 104729, want: 2},\n\t}\n\n\tsv := NewSieve(maxX)\n\
    \n\tfor _, tc := range testCases {\n\t\tt.Run(tc.desc, func(t *testing.T) {\n\t\
    \t\tf := sv.Factorize(tc.x)\n\t\t\tgot := CountDivisors(f)\n\n\t\t\tif tc.want\
    \ != got {\n\t\t\t\tt.Errorf(\"%d divisors num, expected %d, but got %d\", tc.x,\
    \ tc.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc FuzzCountDivisors(f *testing.F)\
    \ {\n\tmaxX := 3 * 100000\n\tsv := NewSieve(maxX)\n\tf.Add(0)\n\tf.Add(1)\n\t\
    f.Add(9)\n\tf.Add(123456)\n\tf.Add(1000000007)\n\tf.Fuzz(func(t *testing.T, a\
    \ int) {\n\t\tif 1 > a || a > maxX {\n\t\t\treturn\n\t\t}\n\t\t// enumerate divisors\
    \ counting methods\n\t\ttype methodFunc func(x int) int\n\t\tmethods := []methodFunc{\n\
    \t\t\t// get len enumerate divisors\n\t\t\tfunc(x int) int {\n\t\t\t\treturn len(Divisors(x))\n\
    \t\t\t},\n\t\t\t// get len enumerate divisors with eratosthenes sieve\n\t\t\t\
    func(x int) int {\n\t\t\t\treturn len(sv.Divisors(x))\n\t\t\t},\n\t\t\t// get\
    \ len from Factiroze\n\t\t\tfunc(x int) int {\n\t\t\t\treturn CountDivisors(Factorize(x))\n\
    \t\t\t},\n\t\t\t// get len from Factorize with sieve\n\t\t\tsv.CountDivisors,\n\
    \t\t}\n\n\t\tfor i, method1 := range methods {\n\t\t\tgot1 := method1(a)\n\t\t\
    \tfor j := i + 1; j < len(methods); j++ {\n\t\t\t\tmethod2 := methods[j]\n\t\t\
    \t\tgot2 := method2(a)\n\t\t\t\tt.Logf(\n\t\t\t\t\t\"%d num divisors, method1:\
    \ %v:%v, but method2 %v:%v\",\n\t\t\t\t\ta,\n\t\t\t\t\tmethod1,\n\t\t\t\t\tgot1,\n\
    \t\t\t\t\tmethod2,\n\t\t\t\t\tgot2,\n\t\t\t\t)\n\t\t\t\tif !reflect.DeepEqual(got1,\
    \ got2) {\n\t\t\t\t\tt.Errorf(\n\t\t\t\t\t\t\"%d num divisors, method1: %v:%v,\
    \ but method2 %v:%v\",\n\t\t\t\t\t\ta,\n\t\t\t\t\t\tmethod1,\n\t\t\t\t\t\tgot1,\n\
    \t\t\t\t\t\tmethod2,\n\t\t\t\t\t\tgot2,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t\
    }\n\t})\n}\n"
  dependsOn:
  - go-acl/verify/associative_array/verify.test.go
  - go-acl/verify/aplusb/verify.test.go
  - go-acl/verify/many_aplusb/verify.test.go
  - go-acl/verify/predecessor_problem/verify.test.go
  - go-acl/verify/double_ended_priority_queue/verify.test.go
  - go-acl/splay/node_test.go
  - go-acl/splay/set_test.go
  - go-acl/splay/node.go
  - go-acl/splay/set.go
  - go-acl/splay/map.go
  - go-acl/util/math_test.go
  - go-acl/util/unionfind.go
  - go-acl/util/depq_test.go
  - go-acl/util/sieve.go
  - go-acl/util/math.go
  - go-acl/util/monoid.go
  - go-acl/util/depq.go
  - go-acl/util/lib_test.go
  - go-acl/util/segmentTree.go
  - go-acl/util/lib.go
  - go-acl/testlib/assert.go
  - go-acl/main.go
  isVerificationFile: false
  path: go-acl/util/sieve_test.go
  requiredBy:
  - go-acl/splay/node_test.go
  - go-acl/splay/set_test.go
  - go-acl/splay/node.go
  - go-acl/splay/set.go
  - go-acl/splay/map.go
  - go-acl/util/math_test.go
  - go-acl/util/unionfind.go
  - go-acl/util/depq_test.go
  - go-acl/util/sieve.go
  - go-acl/util/math.go
  - go-acl/util/monoid.go
  - go-acl/util/depq.go
  - go-acl/util/lib_test.go
  - go-acl/util/segmentTree.go
  - go-acl/util/lib.go
  - go-acl/testlib/assert.go
  - go-acl/main.go
  timestamp: '2024-04-20 13:54:19+09:00'
  verificationStatus: LIBRARY_SOME_WA
  verifiedWith:
  - go-acl/verify/associative_array/verify.test.go
  - go-acl/verify/aplusb/verify.test.go
  - go-acl/verify/many_aplusb/verify.test.go
  - go-acl/verify/predecessor_problem/verify.test.go
  - go-acl/verify/double_ended_priority_queue/verify.test.go
documentation_of: go-acl/util/sieve_test.go
layout: document
redirect_from:
- /library/go-acl/util/sieve_test.go
- /library/go-acl/util/sieve_test.go.html
title: go-acl/util/sieve_test.go
---
