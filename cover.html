
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>go: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">main/go/main.go (41.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "container/heap"
        "fmt"
        "math"
        "os"
        "strconv"
)

var in = bufio.NewScanner(os.Stdin)
var out = bufio.NewWriter(os.Stdout)

type Pair struct {
        u, v int
}

func NewPair(u, v int) *Pair <span class="cov8" title="1">{
        return &amp;Pair{u, v}
}</span>
func (p *Pair) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d %d", p.u, p.v)
}</span>

func init() <span class="cov8" title="1">{
        in.Split(bufio.ScanWords)
        in.Buffer([]byte{}, math.MaxInt64)
}</span>

func reads() string <span class="cov0" title="0">{
        in.Scan()
        return in.Text()
}</span>

func readss(n int) []string <span class="cov0" title="0">{
        ret := make([]string, n)
        for i := range ret </span><span class="cov0" title="0">{
                ret[i] = reads()
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func readrs(n int) [][]rune <span class="cov0" title="0">{
        ret := make([][]rune, n)
        for i := range ret </span><span class="cov0" title="0">{
                ret[i] = []rune(reads())
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func readi() int <span class="cov0" title="0">{
        in.Scan()
        ret, _ := strconv.Atoi(in.Text())
        return ret
}</span>

func readis(n int) []int <span class="cov0" title="0">{
        ret := make([]int, n)
        for i := range ret </span><span class="cov0" title="0">{
                ret[i] = readi()
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func IsPrime(x int) bool <span class="cov8" title="1">{
        if x == 1 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">rx := sqrt(x)
        for i := 2; i &lt;= rx; i++ </span><span class="cov8" title="1">{
                if x%i == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func Factorize(x int) []*Pair <span class="cov8" title="1">{
        if x == 1 </span><span class="cov8" title="1">{
                return []*Pair{}
        }</span>

        <span class="cov8" title="1">rx := sqrt(x)
        n := x
        ret := make([]*Pair, 0)
        for i := 2; i &lt;= rx; i++ </span><span class="cov8" title="1">{
                if n%i != 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">exp := 0
                for n%i == 0 </span><span class="cov8" title="1">{
                        n /= i
                        exp++
                }</span>
                <span class="cov8" title="1">ret = append(ret, NewPair(i, exp))</span>
        }
        <span class="cov8" title="1">if n != 1 </span><span class="cov8" title="1">{
                ret = append(ret, NewPair(n, 1))
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func Divisors(x int) []int <span class="cov8" title="1">{
    ret := make([]int, 0)

    rx := sqrt(x)
    for i := 1; i&lt;= rx; i++ </span><span class="cov8" title="1">{
        if x % i != 0 </span><span class="cov8" title="1">{
            continue</span>
        }
        <span class="cov8" title="1">ret = append(ret, i)
        if i != x/i </span><span class="cov8" title="1">{
            ret = append(ret, x/i)
        }</span>
    }
    <span class="cov8" title="1">return ret</span>
}

func CountDivisors(pairs []*Pair) int <span class="cov8" title="1">{
    ans := 1
    for _, pe := range pairs </span><span class="cov8" title="1">{
        ans *= (pe.v+1)
    }</span>
    <span class="cov8" title="1">return ans</span>
}

// Eratosthenes sieve
type EratosthenesSieve struct {
        isPrime   []bool
        minFactor []int
}

func NewSieve(n int) *EratosthenesSieve <span class="cov8" title="1">{
        isPrime := make([]bool, n+1)
        minFactor := make([]int, n+1)

        for i := range isPrime </span><span class="cov8" title="1">{
                isPrime[i] = true
                minFactor[i] = -1
        }</span>
        <span class="cov8" title="1">isPrime[0] = false
        isPrime[1] = false
        minFactor[1] = 1

        // sieve
        for i := range isPrime </span><span class="cov8" title="1">{
                if !isPrime[i] </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">minFactor[i] = i

                for j := i * 2; j &lt;= n; j += i </span><span class="cov8" title="1">{
                        isPrime[j] = false

                        if minFactor[j] == -1 </span><span class="cov8" title="1">{
                                minFactor[j] = i
                        }</span>
                }
        }
        <span class="cov8" title="1">return &amp;EratosthenesSieve{
                isPrime:   isPrime,
                minFactor: minFactor,
        }</span>
}

func (sv *EratosthenesSieve) IsPrime(x int) bool <span class="cov8" title="1">{
        return sv.isPrime[x]
}</span>

func (sv *EratosthenesSieve) Factorize(x int) []*Pair <span class="cov8" title="1">{
        ret := make([]*Pair, 0)
        n := x
        for n &gt; 1 </span><span class="cov8" title="1">{
                p := sv.minFactor[n]
                exp := 0

                for sv.minFactor[n] == p </span><span class="cov8" title="1">{
                        n /= p
                        exp++
                }</span>
                <span class="cov8" title="1">ret = append(ret, NewPair(p, exp))</span>
        }
        <span class="cov8" title="1">return ret</span>
}

func (sv *EratosthenesSieve) Divisors(x int) []int <span class="cov8" title="1">{
        ret := []int{1}

    f := sv.Factorize(x)
        for _, pe := range f </span><span class="cov8" title="1">{
        n := len(ret)
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        v := 1
                        for j := 0; j &lt; pe.v; j++ </span><span class="cov8" title="1">{
                                v *= pe.u
                                ret = append(ret, ret[i]*v)
                        }</span>
                }
        }
        <span class="cov8" title="1">return ret</span>
}

func (sv *EratosthenesSieve) CountDivisors(x int) int <span class="cov8" title="1">{
    return CountDivisors(sv.Factorize(x))
}</span>

func modPow(x, e, mod int) int <span class="cov8" title="1">{
        i := 1
        ret := 1

        for i &lt;= e </span><span class="cov8" title="1">{
                if i&amp;e &gt; 0 </span><span class="cov8" title="1">{
                        ret = (ret * x) % mod
                }</span>
                <span class="cov8" title="1">i &lt;&lt;= 1
                x = (x * x) % mod</span>
        }
        <span class="cov8" title="1">return ret</span>
}

func inv(x, mod int) int <span class="cov8" title="1">{
        return modPow(x, mod-2, mod)
}</span>

func popBack(a *[]int) int <span class="cov8" title="1">{
        ret := (*a)[len(*a)-1]
        *a = (*a)[:len(*a)-1]
        return ret
}</span>

func popFront(a *[]int) int <span class="cov8" title="1">{
        ret := (*a)[0]
        *a = (*a)[1:]
        return ret
}</span>

func gcd(a, b int) int <span class="cov8" title="1">{
        if b == 0 </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return gcd(b, a%b)</span>
}

func lcm(a, b int) int <span class="cov0" title="0">{
        return a / gcd(a, b) * b
}</span>

func sqrt(x int) int <span class="cov8" title="1">{
        return int(math.Sqrt(float64(x)))
}</span>

func nextPerm(a []int) bool <span class="cov0" title="0">{
        // search i
        i := len(a) - 2
        for i &gt;= 0 &amp;&amp; a[i] &gt;= a[i+1] </span><span class="cov0" title="0">{
                i--
        }</span>
        <span class="cov0" title="0">if i &lt; 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">j := len(a) - 1
        for j &gt;= 0 &amp;&amp; a[j] &lt;= a[i] </span><span class="cov0" title="0">{
                j--
        }</span>

        <span class="cov0" title="0">a[i], a[j] = a[j], a[i]

        l := i + 1
        r := len(a) - 1
        for l &lt; r </span><span class="cov0" title="0">{
                a[l], a[r] = a[r], a[l]
                l++
                r--
        }</span>
        <span class="cov0" title="0">return true</span>
}

func max(x, y int) int <span class="cov0" title="0">{
        if x &gt; y </span><span class="cov0" title="0">{
                return x
        }</span>
        <span class="cov0" title="0">return y</span>
}

func min(x, y int) int <span class="cov0" title="0">{
        if x &lt; y </span><span class="cov0" title="0">{
                return x
        }</span>
        <span class="cov0" title="0">return y</span>
}

func sum(a []int) int <span class="cov0" title="0">{
        sum := 0
        for _, v := range a </span><span class="cov0" title="0">{
                sum += v
        }</span>
        <span class="cov0" title="0">return sum</span>
}

func abs(x int) int <span class="cov0" title="0">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                x = -x
        }</span>
        <span class="cov0" title="0">return x</span>
}

func NewUf(n int) []int <span class="cov0" title="0">{
        uf := make([]int, n)
        for i := range uf </span><span class="cov0" title="0">{
                uf[i] = -1
        }</span>
        <span class="cov0" title="0">return uf</span>
}

func root(uf []int, x int) int <span class="cov0" title="0">{
        if uf[x] &lt; 0 </span><span class="cov0" title="0">{
                return x
        }</span> else<span class="cov0" title="0"> {
                uf[x] = root(uf, uf[x])
                return uf[x]
        }</span>
}

func family(uf []int, x, y int) bool <span class="cov0" title="0">{
        return root(uf, x) == root(uf, y)
}</span>

func size(uf []int, x int) int <span class="cov0" title="0">{
        return -uf[root(uf, x)]
}</span>

func unite(uf []int, x, y int) <span class="cov0" title="0">{
        rx := root(uf, x)
        ry := root(uf, y)
        if rx == ry </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if size(uf, rx) &lt; size(uf, ry) </span><span class="cov0" title="0">{
                rx = rx ^ ry
                ry = rx ^ ry
                rx = rx ^ ry
        }</span>
        <span class="cov0" title="0">uf[rx] += uf[ry]
        uf[ry] = rx</span>
}

type splay_node struct {
        l, r, p *splay_node
        size    int
        value   int
}

func (n *splay_node) rotate() <span class="cov0" title="0">{
        p := n.p

        if pp := p.p; pp != nil </span><span class="cov0" title="0">{
                if pp.l == p </span><span class="cov0" title="0">{
                        pp.l = n
                }</span> else<span class="cov0" title="0"> {
                        pp.r = n
                }</span>
                <span class="cov0" title="0">n.p = pp</span>
        }

        <span class="cov0" title="0">var c *splay_node
        if p.l == n </span><span class="cov0" title="0">{
                c = n.r
                n.r = p
                p.l = c
        }</span> else<span class="cov0" title="0"> {
                c = n.l
                n.l = p
                p.r = c
        }</span>

        <span class="cov0" title="0">if c != nil </span><span class="cov0" title="0">{
                c.p = p
        }</span>
        <span class="cov0" title="0">p.p = n
        p.update()
        n.update()</span>
}

func (n *splay_node) state() int <span class="cov0" title="0">{
        if n.p == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if n.p.l == n </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">if n.p.r == n </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (n *splay_node) splay() <span class="cov0" title="0">{
        for n.p != nil </span><span class="cov0" title="0">{
                // n has parent

                if n.p.state() == 0 </span><span class="cov0" title="0">{
                        // n.p doesn't have p
                        n.rotate()
                }</span>

                <span class="cov0" title="0">if n.state() == n.p.state() </span><span class="cov0" title="0">{
                        n.p.rotate()
                        n.rotate()
                }</span> else<span class="cov0" title="0"> {
                        n.rotate()
                        n.rotate()
                }</span>
        }
}

func (n *splay_node) update() <span class="cov0" title="0">{
        n.size = 1
        if n.l != nil </span><span class="cov0" title="0">{
                n.size += n.l.size
        }</span>
        <span class="cov0" title="0">if n.r != nil </span><span class="cov0" title="0">{
                n.size += n.r.size
        }</span>
}

func get(ind int, root *splay_node) *splay_node <span class="cov0" title="0">{
        now := root
        for </span><span class="cov0" title="0">{
                lsize := 0
                if now.l != nil </span><span class="cov0" title="0">{
                        lsize = now.l.size
                }</span>
                <span class="cov0" title="0">if ind &lt; lsize </span><span class="cov0" title="0">{
                        now = now.l
                }</span>
                <span class="cov0" title="0">if ind == lsize </span><span class="cov0" title="0">{
                        now.splay()
                        return now
                }</span>
                <span class="cov0" title="0">if ind &gt; lsize </span><span class="cov0" title="0">{
                        now = now.r
                        ind -= lsize + 1
                }</span>
        }
}

type heapImpl []int

func (h heapImpl) Len() int           <span class="cov0" title="0">{ return len(h) }</span>
func (h heapImpl) Less(i, j int) bool <span class="cov0" title="0">{ return h[i] &lt; h[j] }</span>
func (h heapImpl) Swap(i, j int)      <span class="cov0" title="0">{ h[i], h[j] = h[j], h[i] }</span>

func (h *heapImpl) Push(x interface{}) <span class="cov0" title="0">{
        *h = append(*h, x.(int))
}</span>
func (h *heapImpl) Pop() interface{} <span class="cov0" title="0">{
        x := (*h)[len(*h)-1]
        *h = (*h)[:len(*h)-1]
        return x
}</span>

type PriorityQueue struct {
        value heapImpl
}

func NewPriorityQueue() *PriorityQueue <span class="cov0" title="0">{
        value := &amp;heapImpl{}
        heap.Init(value)
        return &amp;PriorityQueue{}
}</span>

func (pq *PriorityQueue) Push(x int) <span class="cov0" title="0">{
        heap.Push(&amp;pq.value, x)
}</span>

func (pq *PriorityQueue) Pop() int <span class="cov0" title="0">{
        x := heap.Pop(&amp;pq.value)
        return x.(int)
}</span>

func NewGraph(n int) [][]int <span class="cov0" title="0">{
        g := make([][]int, n)
        for i := range g </span><span class="cov0" title="0">{
                g[i] = make([]int, 0)
        }</span>
        <span class="cov0" title="0">return g</span>
}

func main() <span class="cov0" title="0">{
        defer out.Flush()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
